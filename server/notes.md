# FsApi app

FreeSWITCH `mod_xml_curl`
is configured to send requests
to the `fsapi` app's `/fsapi` endpoint

Requests contain POST data
as URL-encoded dicts of key/value pairs.

The Django project
is configured to allow requests to the `fsapi` endpoint
only from localhost.

Django CSRF protection
is disabled for the `/fsapi` endpoint.

It's probably possible to configure `mod_xml_curl`
to use cookies
and enable CSRF protection for the endpoint,
but since the endpoint is accessible
only on localhost,
I haven't bothered to do so.

The `fsapi` app
autoloads `fsapi` modules
in other apps on Django start,
and the `fsapi` modules
declare and register request handlers
in a global handler registry.

Request handler classes
initialize a list of keys and values
that must be present in a request's POST data
before they are selected to process the request.

Handler classes also implement a `process` method
that returns a template and context
that the `/fsapi` view uses
to generate its response.

When it receives a request,
the `/fsapi` endpoint view
compares POST data
to key/value triggers
of the handler objects
in the registry,
and if it finds a match,
calls the object's `process` method
and responds to the request
by rendering and the template and context
returned by the handler.

The requests handler registry
is a simple array,
so the first matching handler
processes the request.

The `/fsapi` endpoint view
raises 404 when no request handler
matches the request's POST data.

Handler objects raise 404
when they raise `KeyError` or `ValueError`
when expected keys or values
are missing from POST data,
or when they explicitly raise 404
due to some other error condition.

The app provides
a custom 404 method
that returns
a FreeSWITCH XML fragment.

The `common` app default 404 handler
detects the custom 404 method
and returns its result
instead of the default HTML 404 response.

Request handler class implementations
return this 404 fragment
when they raise Django `Http404`.


# Channels app

The `channels` app
models channels as
a randomly generated UUID ID,
an authentication realm
and a set of clients.

Channels can be private or public.

Public channels
are listed on the index page.

A client is modelled
as a randomly generated UUID client ID,
a randomly generated UUID password,
a client-generated UUID session ID,
a channel reference
and a timestamp field
to indicate whether the client
is connected or not.

The `channels` app
registers `fsapi` request handlers
to handle the verto module configuration
and user authentication requests
generated by `mod_xml_curl`,
and also to handle
verto login and disconnect events
sent from FreeSWITCH
by custom Lua hook scripts.

The app provides a registry for,
and autoloads `channels` modules
in other apps
that register per-realm
channel auth handlers.


# Channels app auth realm

The `channels` app Channel model
contains a `realm` field,
and the app autoloads `channels` modules
in other apps on Django start
to register per-app auth realm handlers.

The channel auth handler registry
is a dict that maps auth realm strings
to handler objects.

When a client sends a request
to log in to a verto endpoint,
`mod_xml_curl` POSTs the request
to the `/fsapi` endpoint
and the `fsapi` app
inspects the POST data
and hands the request
to the `channels` app auth request handler.

The `channels` app
auth request handler
retrieves a Client object
from POSTed login username
and looks in the auth realm registry
for an app-specific handler
that matches the realm
listed in the Client object's
Channel reference.

The selected auth realm handler
processes the request
and returns a FreeSWITCH user directory
configuration document.

FreeSWITCH uses the app-generated document
to authenticate the login request
and to configure various vars and params
for the logged-in user.

The `peers` app,
for example,
returns a directory document
that allows logged-in clients
to send only a subset
of verto protocol messages,
and that allows clients to broadcast
only to the Client object's
Channel reference channel ID.


# Verto punt API command

I've slightly modified
the verto module
in the FreeSWITCH binaries
used in the project
to require a non-empty session ID on login
and to provide a `verto_punt` API command
that can be used
to punt logged-in connections
by session ID.

I've raised a
[GitHub issue](https://github.com/signalwire/freeswitch/issues/832)
to discuss and include the changes
in the official release,
but since I'm compiling anyhow,
I don't mind adding the changes
by hand when I build.

The project
uses the `verto_punt` command
to deny login of multiple clients
using the same username/password,
and could possibly be used
to limit the number of connected clients
per channel.


# Channels app login/disconnect event handlers

The FreeSWITCH repo's Lua module 
is configured to run hook scripts
on verto login and disconnect events.

The hook scripts
use FreeSWITCH's `curl` API command
to POST requests to the Django app's `/fsapi` endpoint
on successful client login events
and on all client disconnect events.

The `channels` app
registers handlers for the events.

The client login handler
queries a Client object
based on POSTed login username
and sends `punt` to the hook script
when the login event's session ID
is not the expected value,
or updates the Client's connected timestamp
when it is.

When the hook script receives `punt` in response,
it calls the `verto_punt` API command
to terminate the login.

The client disconnect handler
queries a Client object
based on POSTed event data login username
and removes the object's connected timestamp
when it exists.

(Disconnect events
may or may not
be associated with a logged-in client,
and the request handler sees `nil`
when a client disconnects
before successful login.)


# Verto peer-to-peer message relay

The FreeSWITCH repo's Lua module 
is configured to run a hook script
on all `MESSAGE` events.

Clients send messages directly to other clients
with `verto.info` messages
that include the `msg` param.

The verto module
generates a global `MESSAGE` event
from the verto event
and the script processes the message
and sends the message's body
directly to the target client
using the FreeSWITCH `chat` API command
`verto` protocol.

Clients base-64 encode these relayed info messages
before sending and decode upon receipt
to avoid corruption by the `chat` command.


# Peers app

The `peers` app
provides a channel-specific endpoint/view
that reads the `channels` app
channel detail template
and inserts the JavaScript peer client
built by the `pbx-client` npm project repo
webpack script.

The `peers` app
provides a `sessions` endpoint/view
to receive requests from JavaScript clients
for authentication credentials.

The `sessions` view
receives a `sessionId` UUID
as a request argument
and returns `clientId` and `password`
in a JSON response.

When it receives a request,
the view queries Client objects
based on incoming `sessionId`
and creates a new object
if one can't be found.

Beyond knowledge of a channel ID,
there's no restriction on client requests
to the `sessions` endpoint.

Client objects
expire after two weeks,
and the view returns 404
when the Client object
associated with a requested `sessionId`
has expired.

The view
returns 403 on other errors,
including non-UUID session ID.
