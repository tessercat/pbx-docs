# Channel security

Clients must know a valid
per-channel login username (client ID) and password
before logging in
(connecting a WebSocket client
and authenticating the connection
with the verto endpoint)
to a channel.

Channel ID, client ID and password
are random UUIDs
generated by the Django `channels` app.

Channels are either public or private.

Public channels
are listed on the channels index page
and private channels are not.

Joining a channel
requires nothing more
than knowledge of the channel ID.

Since UUID address space is so huge,
I assume that private channels
are essentially inaccessible
without that knowledge.

The Django `channels` app
generates new Client objects
and stores Client IDs
in per-channel session variables,
when a browser requests a channel page
for the first time,
when sessions expire,
or when the Django session cookie
is deleted from the browser.

The Django `channels` app
delivers the server-generated Client object
login username (client ID) and password
to the JavaScript client
as values in DOM input elements.

The verto module
requires user configuration
to specify allowed event channels per user.
The `channels` app
auth request handler
adds the channel UUID
to allowed event channels,
so logged-in clients
are able to broadcast to a single channel only.

Clients
can send peer-to-peer messages
(relayed by the verto module)
to clients in the same or other channels,
but client ID must be known.

Since the channel system is essentially
a means for clients to discover
each other's client ID,
while it's technically possible
for clients to send
messages between channels,
the address space of UUIDs is so huge
that I assume that channels
are effectively isolated from one another
unless a user
knows more than one channel ID.
Even then,
I don't see the point.

By default,
the verto module
disconnects (`verto.punt`) a logged-in client
when another client
re-uses the same auth credentials
*and session ID*,
but the module allows new connections
if username and password are correct
but the session ID is different.

This allows nefarious actors
to connect any number of clients
once login ID and password are known.

Also by default,
the verto module
provides no mechanism to disconnect
logged-in clients.

To prevent misuse
of the default verto module
"multiple registration" scheme,
I've added a custom `verto_punt` API command
to the verto module
and a Lua hook script
that listens for verto logins
and punts clients whose
session ID is not the same as
their login ID.

This at least allows hackers
to connect only a single client
at a time
per login username and password.

Once a WebRTC connection is established,
media streams
are transmitted directly peer-to-peer,
and the call server
has no knowledge of them at all.

I don't see how media streams
can be compromised
except at the endpoints themselves.

I also don't see a risk
in exposing the client ID login username,
but it's always possible
I'm missing something.

For peer-to-peer messages,
the verto module
inserts login username (client ID)
into the `MESSAGE` event `from_user` field,
and the target peer receives this value
in the received event's `msg.from` field.

When Peer objects
check expected peer ID
against the `from` field of incoming messages,
I'm fairly sure
it's not possible
for third parties
to interfere in peer-to-peer messaging dialogues.

I also don't see
any potential for XSS injection.

Since username/password are easily discovered,
nefarious Internet denizens
can easily re-use
the pub/sub/peer-to-peer signal channel
for whatever purpose they devise,
but hopefully
I've minimized the possibility
bad-faith actors
interfering with
the channel layer's intended purpose
of providing a medium
to discover other peers
and negotiate peer-to-peer
WebRTC voice and video calls
with them.

I'm sure someone
with a more malevolent imagination
will eventually prove me wrong.
