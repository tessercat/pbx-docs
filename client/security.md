# Channel security

Clients must know a valid
per-channel login username (client ID) and password
before logging in (connecting a WebSocket)
to a channel.

Channel ID, client ID and password
are random UUIDs
generated by the Django `channels` app.

Client IDs are kept in per-channel
Django session variables,
and new Client objects are generated
when channel/client keys are missing
and when sessions expire.

Login username (client ID) and password
are delivered to the view
as values in DOM input elements.

The verto module
requires user configuration
to specify allowed event channels per user,
and since the `channels` app
auth request handler
adds only the channel UUID
to allowed event channels,
logged-in clients
are able to broadcast to a single channel only,
and can send peer-to-peer messages
only to other clients of that channel.

By default,
the verto module
disconnects (`verto.punt`) a logged-in client
when another client
re-uses the same auth credentials
*and session ID*,
but the module allows new connections
if username and password are correct
but the session ID is different.

This allows nefarious actors
to connect any number of clients
once login ID and password are known.

Also by default,
the verto module
provides no mechanism to disconnect
logged-in clients.

To prevent misuse
of such a "multiple registration" scheme,
I've added a custom `verto_punt` API command
to the verto module
and a Lua hook script
that listens for verto logins
and punts clients whose
session ID is not the same as
their login ID.

This at least allows hackers
to connect only a single client
at a time
per login username and password.

Once a WebRTC connection is established,
media streams
are transmitted directly peer-to-peer,
and the call server
has no knowledge of them at all.

I don't see how media streams
can be compromised
except at the endpoints themselves.

I also don't see a risk
in exposing the client ID login username,
but it's always possible
I'm missing something.

For peer-to-peer messages,
the verto module
inserts `sessid`
into the `MESSAGE` event `from_user` field,
and the target peer receives this value
in the received event's `msg.from` field.

When Peer objects
check expected peer ID
against the `from` field of incoming messages,
I'm fairly sure
it's not possible
for third parties
to interfere in peer-to-peer messaging dialogues.

Since username/password are easily discovered,
nefarious Internet denizens
can easily re-use
the pub/sub/peer-to-peer signal channel
for whatever purpose they devise,
but hopefully
I've minimized the possibility
of allowing such bad-faith actors
to interfere with
the channel layer's intended purpose
of providing a medium
to negotiate peer-to-peer
WebRTC voice and video calls.

I'm sure someone
with a more malevolent imagination
will eventually prove me wrong.
